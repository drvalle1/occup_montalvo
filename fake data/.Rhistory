#get data
tmp=read.csv('fake data y.csv',as.is=T)
nspp=nrow(tmp)/(nrep*nloc); nspp
y=array(tmp$V1,dim=c(nloc,nspp,nrep))
#design matrix for detection
tmp=read.csv('fake data xmat det.csv',as.is=T)
nparam.det=nrow(tmp)/(nloc*nrep); nparam.det
xmat.det=array(tmp$V1,dim=c(nloc,nparam.det,nrep))
#basic settings
ngr=10
ngibbs=1000
nburn=ngibbs/2
tau2.betas=0.1
#priors
tau2.a=0.1; tau2.b=0.1
gamma1=0.1
#initial values
nspp=ncol(y[,,1])
nloc=nrow(xmat.occ)
nparam.occ=ncol(xmat.occ)
nparam.det=ncol(xmat.det[,,1])
ystar=y
ystar=ifelse(y==1,1,-1)
m.betas=matrix(0,nparam.occ,ngr)
w=sample(1:ngr,size=nspp,replace=T)
alpha.s=rep(0,nspp)
betas=matrix(0,nparam.occ,nspp)
theta=rep(1/ngr,ngr)
z=apply(y,c(1,2),max)
zstar=matrix(ifelse(z==1,1,-1),nloc,nspp)
m.gamma=rep(0,nparam.det)
tau2.gamma=rep(1,nparam.det)
m.alpha=0
tau2.alpha=1
gammas=matrix(0,nparam.det,nspp)
#MCMC settings
store.alpha.s=matrix(NA,ngibbs,nspp)
store.m.alpha=matrix(NA,ngibbs,1)
store.tau2.alpha=matrix(NA,ngibbs,1)
store.gammas=matrix(NA,ngibbs,nparam.det*nspp)
store.m.gamma=matrix(NA,ngibbs,nparam.det)
store.tau2.gamma=matrix(NA,ngibbs,nparam.det)
store.betas=matrix(NA,ngibbs,nparam.occ*nspp)
store.m.betas=matrix(NA,ngibbs,nparam.occ*ngr)
store.w=matrix(NA,ngibbs,nspp)
store.theta=matrix(NA,ngibbs,ngr)
options(warn=2)
alpha.s.mat=matrix(alpha.s,nloc,nspp)
media.occ=alpha.s.mat+xmat.occ%*%betas
Phi.occ=pnorm(media.occ)
One_Phi.occ=1-Phi.occ
One_Phi.det=Phi.det=array(NA,dim=c(nloc,nspp,nrep))
for (i in 1:nrep){
media.det=xmat.det[,,i]%*%gammas
Phi.det[,,i]=pnorm(media.det)
One_Phi.det[,,i]=1-Phi.det[,,i]
}
dim(y)
y1=y[,i,]
dim(y1)
tmp=rowSums(y1)
cond=tmp==0
sum(cond)
cond=tmp==0
lp1=rowSums(log(One.Phi.det[cond,i,]))+log(Phi.occ[cond,i])
p2=One_Phi.cc[cond,i]
#calculate important stuff
alpha.s.mat=matrix(alpha.s,nloc,nspp)
media.occ=alpha.s.mat+xmat.occ%*%betas
Phi.occ=pnorm(media.occ)
One_Phi.occ=1-Phi.occ
One_Phi.det=Phi.det=array(NA,dim=c(nloc,nspp,nrep))
for (i in 1:nrep){
media.det=xmat.det[,,i]%*%gammas
Phi.det[,,i]=pnorm(media.det)
One_Phi.det[,,i]=1-Phi.det[,,i]
}
i=1
y1=y[,i,]
tmp=rowSums(y1)
#all observations are equal to zero
cond=tmp==0
lp1=rowSums(log(One.Phi.det[cond,i,]))+log(Phi.occ[cond,i])
p2=One_Phi.cc[cond,i]
cond=tmp==0
lp1=rowSums(log(One_Phi.det[cond,i,]))+log(Phi.occ[cond,i])
lprob=rep(NA,nloc)
y1=y[,i,]
tmp=rowSums(y1)
#all observations are equal to zero
cond=tmp==0
lp1=rowSums(log(One_Phi.det[cond,i,]))+log(Phi.occ[cond,i])
p2=One_Phi.occ[cond,i]
lprob[cond]=exp(lp1)+p2
pl1=y1[!cond,]*log(Phi.det[!cond,i,])+(1-y1[!cond,])*log(One_Phi.det[!cond,i,])
lp1=y1[!cond,]*log(Phi.det[!cond,i,])+(1-y1[!cond,])*log(One_Phi.det[!cond,i,])
lprob=rep(NA,nloc)
y1=y[,i,]
tmp=rowSums(y1)
#all observations are equal to zero
cond=tmp==0
lp1=rowSums(log(One_Phi.det[cond,i,]))+log(Phi.occ[cond,i])
p2=One_Phi.occ[cond,i]
lprob[cond]=exp(lp1)+p2
lp1=y1[!cond,]*log(Phi.det[!cond,i,])+(1-y1[!cond,])*log(One_Phi.det[!cond,i,])
lp2=rowSums(lp1)+log(Phi.occ[!cond,i])
lprob[!cond]=lp2
lprob
fim=rep(NA,nspp)
for (i in 1:nspp){
lprob=rep(NA,nloc)
y1=y[,i,]
tmp=rowSums(y1)
#all observations are equal to zero
cond=tmp==0
lp1=rowSums(log(One_Phi.det[cond,i,]))+log(Phi.occ[cond,i])
p2=One_Phi.occ[cond,i]
lprob[cond]=log(exp(lp1)+p2)
#at least one observations is equal to 1
lp1=y1[!cond,]*log(Phi.det[!cond,i,])+(1-y1[!cond,])*log(One_Phi.det[!cond,i,])
lp2=rowSums(lp1)+log(Phi.occ[!cond,i])
lprob[!cond]=lp2
fim[i]=sum(lprob)
}
fim
alpha.s.mat=matrix(alpha.s,nloc,nspp)
media.occ=alpha.s.mat+xmat.occ%*%betas
Phi.occ=pnorm(media.occ)
One_Phi.occ=1-Phi.occ
One_Phi.det=Phi.det=array(NA,dim=c(nloc,nspp,nrep))
for (i in 1:nrep){
media.det=xmat.det[,,i]%*%gammas
Phi.det[,,i]=pnorm(media.det)
One_Phi.det[,,i]=1-Phi.det[,,i]
}
#get llk
fim=rep(NA,nspp)
for (i in 1:nspp){
lprob=rep(NA,nloc)
y1=y[,i,]
tmp=rowSums(y1)
#all observations are equal to zero
cond=tmp==0
lp1=rowSums(log(One_Phi.det[cond,i,]))+log(Phi.occ[cond,i])
p2=One_Phi.occ[cond,i]
lprob[cond]=log(exp(lp1)+p2)
#at least one observations is equal to 1
lp1=y1[!cond,]*log(Phi.det[!cond,i,])+(1-y1[!cond,])*log(One_Phi.det[!cond,i,])
lp2=rowSums(lp1)+log(Phi.occ[!cond,i])
lprob[!cond]=lp2
fim[i]=sum(lprob)
}
rm(list=ls())
library('mvtnorm')
set.seed(35)
#basic settings
nrep=5
#get functions
setwd('U:\\GIT_models\\occup_montalvo')
source('aux occup montalvo.R')
source('gibbs_occup_montalvo.R')
#get design matrix for occupancy
setwd('U:\\GIT_models\\occup_montalvo\\fake data')
xmat.occ=data.matrix(read.csv('fake data xmat occ.csv',as.is=T))
xtx.occ=t(xmat.occ)%*%xmat.occ
nparam.occ=ncol(xmat.occ)
nloc=nrow(xmat.occ)
#get data
tmp=read.csv('fake data y.csv',as.is=T)
nspp=nrow(tmp)/(nrep*nloc); nspp
y=array(tmp$V1,dim=c(nloc,nspp,nrep))
#design matrix for detection
tmp=read.csv('fake data xmat det.csv',as.is=T)
nparam.det=nrow(tmp)/(nloc*nrep); nparam.det
xmat.det=array(tmp$V1,dim=c(nloc,nparam.det,nrep))
#basic settings
ngr=10
ngibbs=1000
nburn=ngibbs/2
tau2.betas=0.1
#priors
tau2.a=0.1; tau2.b=0.1
gamma1=0.1
#initial values
nspp=ncol(y[,,1])
nloc=nrow(xmat.occ)
nparam.occ=ncol(xmat.occ)
nparam.det=ncol(xmat.det[,,1])
ystar=y
ystar=ifelse(y==1,1,-1)
m.betas=matrix(0,nparam.occ,ngr)
w=sample(1:ngr,size=nspp,replace=T)
alpha.s=rep(0,nspp)
betas=matrix(0,nparam.occ,nspp)
theta=rep(1/ngr,ngr)
z=apply(y,c(1,2),max)
zstar=matrix(ifelse(z==1,1,-1),nloc,nspp)
m.gamma=rep(0,nparam.det)
tau2.gamma=rep(1,nparam.det)
m.alpha=0
tau2.alpha=1
gammas=matrix(0,nparam.det,nspp)
#MCMC settings
store.alpha.s=matrix(NA,ngibbs,nspp)
store.m.alpha=matrix(NA,ngibbs,1)
store.tau2.alpha=matrix(NA,ngibbs,1)
store.gammas=matrix(NA,ngibbs,nparam.det*nspp)
store.m.gamma=matrix(NA,ngibbs,nparam.det)
store.tau2.gamma=matrix(NA,ngibbs,nparam.det)
store.betas=matrix(NA,ngibbs,nparam.occ*nspp)
store.m.betas=matrix(NA,ngibbs,nparam.occ*ngr)
store.w=matrix(NA,ngibbs,nspp)
store.theta=matrix(NA,ngibbs,ngr)
store.llk=matrix(NA,ngibbs,1)
options(warn=2)
#start gibbs sampler
for (i in 1:ngibbs){
print(i)
print(table(w))
#update latent variables
z=sample.z(xmat.occ=xmat.occ,betas=betas,nloc=nloc,alpha.s=alpha.s,
nspp=nspp,nrep=nrep,y=y,xmat.det=xmat.det,gammas=gammas)
# z=z.true
zstar=sample.zstar(z=z,xmat.occ=xmat.occ,betas=betas,nloc=nloc,nspp=nspp,
alpha.s=alpha.s)
# zstar=zstar.true
ystar=sample.ystar(nrep=nrep,xmat.det=xmat.det,gammas=gammas,
y=y,nspp=nspp)
# ystar=ystar.true
#update intercept and associated prior parameters
alpha.s=sample.alpha.s(m.alpha=m.alpha,tau2.alpha=tau2.alpha,
xmat.occ=xmat.occ,zstar=zstar,nspp=nspp,
w=w,betas=betas,nloc=nloc)
m.alpha=sample.m.alpha(nspp=nspp,alpha.s=alpha.s,tau2.alpha=tau2.alpha)
tau2.alpha=sample.tau2.alpha(nspp=nspp,alpha.s=alpha.s,
m.alpha=m.alpha,tau2.a=tau2.a,tau2.b=tau2.b)
#update gammas and associated prior parameters
gammas=sample.gammas(ystar=ystar,xmat.det=xmat.det,z=z,m.gamma=m.gamma,tau2.gamma=tau2.gamma,
nparam.det=nparam.det,nspp=nspp,nrep=nrep)
m.gamma=sample.m.gamma(gammas=gammas,tau2.gamma=tau2.gamma,nspp=nspp,nparam.det=nparam.det)
tau2.gamma=sample.tau2.gamma(gammas=gammas,m=m.gamma,nspp=nspp,tau2.a=tau2.a,
tau2.b=tau2.b,nparam.det=nparam.det)
#sample betas and associated prior parameters
betas=sample.betas(m.betas=m.betas,tau2.betas=tau2.betas,xmat.occ=xmat.occ,
zstar=zstar,nspp=nspp,nparam.occ=nparam.occ,
w=w,xtx.occ=xtx.occ,alpha.s=alpha.s)
# betas=betas.true
m.betas=sample.m.betas(w=w,betas=betas,tau2.betas=tau2.betas,nparam.occ=nparam.occ,ngr=ngr)
#sample other parameters
w=sample.w(tau2.betas=tau2.betas,betas=betas,ltheta=log(theta),w=w,
ngr=ngr,m.betas=m.betas,nparam.occ=nparam.occ)
theta=sample.theta(gamma1=gamma1,w=w,ngr=ngr)
# theta=rep(1/ngr,ngr)
llk=get.llk(alpha.s=alpha.s,nloc=nloc,nspp=nspp,betas=betas,
xmat.occ=xmat.occ,xmat.det=xmat.det,y=y,gammas=gammas)
#re-order w from time to time
if (i<nburn & i%%50==0){
ind=order(theta,decreasing=T)
theta=theta[ind]
m.betas=m.betas[,ind]
wnew=w
for (j in 1:ngr){
cond=w==ind[j]
wnew[cond]=j
}
w=wnew
}
#store results
store.betas[i,]=betas
store.m.betas[i,]=m.betas
store.alpha.s[i,]=alpha.s
store.m.alpha[i,]=m.alpha
store.tau2.alpha[i,]=tau2.alpha
store.gammas[i,]=gammas
store.m.gamma[i,]=m.gamma
store.tau2.gamma[i,]=tau2.gamma
store.w[i,]=w
store.theta[i,]=theta
store.llk[i]=llk
}
rm(list=ls())
library('mvtnorm')
set.seed(35)
#basic settings
nrep=5
#get functions
setwd('U:\\GIT_models\\occup_montalvo')
source('aux occup montalvo.R')
source('gibbs_occup_montalvo.R')
#get design matrix for occupancy
setwd('U:\\GIT_models\\occup_montalvo\\fake data')
xmat.occ=data.matrix(read.csv('fake data xmat occ.csv',as.is=T))
xtx.occ=t(xmat.occ)%*%xmat.occ
nparam.occ=ncol(xmat.occ)
nloc=nrow(xmat.occ)
#get data
tmp=read.csv('fake data y.csv',as.is=T)
nspp=nrow(tmp)/(nrep*nloc); nspp
y=array(tmp$V1,dim=c(nloc,nspp,nrep))
#design matrix for detection
tmp=read.csv('fake data xmat det.csv',as.is=T)
nparam.det=nrow(tmp)/(nloc*nrep); nparam.det
xmat.det=array(tmp$V1,dim=c(nloc,nparam.det,nrep))
#basic settings
ngr=10
ngibbs=1000
nburn=ngibbs/2
tau2.betas=0.1
#priors
tau2.a=0.1; tau2.b=0.1
gamma1=0.1
#run gibbs
mod1=gibbs_occup(y=y,xmat.occ=xmat.occ,xmat.det=xmat.det,ngr=ngr,
tau2.a=tau2.a,tau2.b=tau2.b,gamma1=gamma1,
ngibbs=ngibbs,nburn=nburn,tau2.betas=tau2.betas)
rm(list=ls())
library('mvtnorm')
set.seed(35)
#basic settings
nrep=5
#get functions
setwd('U:\\GIT_models\\occup_montalvo')
source('aux occup montalvo.R')
source('gibbs_occup_montalvo.R')
#get design matrix for occupancy
setwd('U:\\GIT_models\\occup_montalvo\\fake data')
xmat.occ=data.matrix(read.csv('fake data xmat occ.csv',as.is=T))
xtx.occ=t(xmat.occ)%*%xmat.occ
nparam.occ=ncol(xmat.occ)
nloc=nrow(xmat.occ)
#get data
tmp=read.csv('fake data y.csv',as.is=T)
nspp=nrow(tmp)/(nrep*nloc); nspp
y=array(tmp$V1,dim=c(nloc,nspp,nrep))
#design matrix for detection
tmp=read.csv('fake data xmat det.csv',as.is=T)
nparam.det=nrow(tmp)/(nloc*nrep); nparam.det
xmat.det=array(tmp$V1,dim=c(nloc,nparam.det,nrep))
#basic settings
ngr=10
ngibbs=1000
nburn=ngibbs/2
tau2.betas=0.1
#priors
tau2.a=0.1; tau2.b=0.1
gamma1=0.1
#run gibbs
mod1=gibbs_occup(y=y,xmat.occ=xmat.occ,xmat.det=xmat.det,ngr=ngr,
tau2.a=tau2.a,tau2.b=tau2.b,gamma1=gamma1,
ngibbs=ngibbs,nburn=nburn,tau2.betas=tau2.betas)
rm(list=ls())
library('mvtnorm')
set.seed(35)
#basic settings
nrep=5
#get functions
setwd('U:\\GIT_models\\occup_montalvo')
source('aux occup montalvo.R')
source('gibbs_occup_montalvo.R')
#get design matrix for occupancy
setwd('U:\\GIT_models\\occup_montalvo\\fake data')
xmat.occ=data.matrix(read.csv('fake data xmat occ.csv',as.is=T))
xtx.occ=t(xmat.occ)%*%xmat.occ
nparam.occ=ncol(xmat.occ)
nloc=nrow(xmat.occ)
#get data
tmp=read.csv('fake data y.csv',as.is=T)
nspp=nrow(tmp)/(nrep*nloc); nspp
y=array(tmp$V1,dim=c(nloc,nspp,nrep))
#design matrix for detection
tmp=read.csv('fake data xmat det.csv',as.is=T)
nparam.det=nrow(tmp)/(nloc*nrep); nparam.det
xmat.det=array(tmp$V1,dim=c(nloc,nparam.det,nrep))
#basic settings
ngr=10
ngibbs=1000
nburn=ngibbs/2
tau2.betas=0.1
#priors
tau2.a=0.1; tau2.b=0.1
gamma1=0.1
#run gibbs
mod1=gibbs_occup(y=y,xmat.occ=xmat.occ,xmat.det=xmat.det,ngr=ngr,
tau2.a=tau2.a,tau2.b=tau2.b,gamma1=gamma1,
ngibbs=ngibbs,nburn=nburn,tau2.betas=tau2.betas)
str(mod1)
rm(list=ls())
library('mvtnorm')
set.seed(35)
#basic settings
nrep=5
#get functions
setwd('U:\\GIT_models\\occup_montalvo')
source('aux occup montalvo.R')
source('gibbs_occup_montalvo.R')
#get design matrix for occupancy
setwd('U:\\GIT_models\\occup_montalvo\\fake data')
xmat.occ=data.matrix(read.csv('fake data xmat occ.csv',as.is=T))
xtx.occ=t(xmat.occ)%*%xmat.occ
nparam.occ=ncol(xmat.occ)
nloc=nrow(xmat.occ)
#get data
tmp=read.csv('fake data y.csv',as.is=T)
nspp=nrow(tmp)/(nrep*nloc); nspp
y=array(tmp$V1,dim=c(nloc,nspp,nrep))
#design matrix for detection
tmp=read.csv('fake data xmat det.csv',as.is=T)
nparam.det=nrow(tmp)/(nloc*nrep); nparam.det
xmat.det=array(tmp$V1,dim=c(nloc,nparam.det,nrep))
#basic settings
ngr=10
ngibbs=1000
nburn=ngibbs/2
tau2.betas=0.1
#priors
tau2.a=0.1; tau2.b=0.1
gamma1=0.1
#run gibbs
mod1=gibbs_occup(y=y,xmat.occ=xmat.occ,xmat.det=xmat.det,ngr=ngr,
tau2.a=tau2.a,tau2.b=tau2.b,gamma1=gamma1,
ngibbs=ngibbs,nburn=nburn,tau2.betas=tau2.betas)
compare1=function(estim,true){
rango=range(c(true,estim))
plot(true,estim,ylim=rango,xlim=rango)
lines(rango,rango,col='red',lwd=2)
}
plot(mod1$llk,type='l')
ngibbs
seq1=500:ngibbs
plot(mod1$llk[seq1],type='l')
plot(mod1$theta[ngibbs,],type='h')
set.seed(32)
#basic settings
nloc=1000
nrep=5
nspp=150
ngr=3
nparam.occ=4
nparam.det=3
#latent group membership
w.true=w=sample(1:ngr,size=nspp,replace=T)
#OCCUPANCY
#parameters
seq1=seq(from=-2,to=2,by=1)
m.betas.true=m.betas=matrix(sample(seq1,size=nparam.occ*ngr,replace=T),
nparam.occ,ngr)
tau2.betas=0.1 #set by user
#get betas
betas=matrix(NA,nparam.occ,nspp)
for (i in 1:nspp){
mu1=m.betas[,w[i]]
betas[,i]=rnorm(nparam.occ,mean=mu1,sd=sqrt(tau2.betas))
}
betas.true=betas
#visualize betas
rango=range(betas)
par(mfrow=c(3,1),mar=rep(1,4))
for (i in 1:ngr) image(betas[,w==i],zlim=rango)
#get intercepts
alpha.s.true=alpha.s=runif(nspp,min=-0.2,max=0.2)
alpha.mat=matrix(alpha.s,nloc,nspp,byrow=T)
#get covariates for occupancy
xmat.occ=matrix(rnorm(nloc*nparam.occ),nloc,nparam.occ)
#generate occupancy status
media=alpha.mat+xmat.occ%*%betas
zstar.true=zstar=matrix(rnorm(nloc*nspp,mean=media,sd=1),nloc,nspp)
z.true=z=matrix(ifelse(zstar>0,1,0),nloc,nspp)
#---------------------------------
#---------------------------------
#DETECTION
tau2.gamma.true=tau2.gamma=runif(nparam.det,min=0,max=0.3)
m.gamma.true=m.gamma=runif(nparam.det,min=-1,max=1)
gammas=matrix(NA,nparam.det,nspp)
for (i in 1:nparam.det){
gammas[i,]=rnorm(nspp,mean=m.gamma[i],sd=sqrt(tau2.gamma[i]))
}
gammas.true=gammas
#get covariates for detection
xmat.det=array(NA,dim=c(nloc,nparam.det,nrep))
for (i in 1:nrep){
tmp=rnorm(nloc*(nparam.det-1))
tmp1=cbind(1,matrix(tmp,nloc,nparam.det-1))
xmat.det[,,i]=tmp1
}
#generate observations
media=ystar=y=array(NA,dim=c(nloc,nspp,nrep))
for (i in 1:nrep){
media[,,i]=xmat.det[,,i]%*%gammas
ystar[,,i]=rnorm(nloc*nspp,mean=media[,,i],sd=1)
#site has to be occupied and species has to have been detected
y[,,i]=ifelse(ystar[,,i]>0 & z.true==1,1,0)
}
ystar.true=ystar
plot(mod1$theta[ngibbs,],type='h')
aux=data.frame(w.true=w.true,w.estim=mod1$w[ngibbs,])
k=table(aux); k
seq1=c(3,1,2)
k[,seq1]
betas.estim=matrix(mod1$betas[ngibbs,],nparam.occ,nspp)
compare1(estim=betas.estim,true=betas.true)
ngr=10
m.betas.estim=matrix(mod1$m.betas[ngibbs,],nparam.occ,ngr)
ind=seq1
compare1(m.betas.estim[,ind],m.betas.true)
alpha.s.estim=mod1$alpha.s[ngibbs,]
compare1(estim=alpha.s.estim,true=alpha.s.true)
gammas.estim=matrix(mod1$gammas[ngibbs,],nparam.det,nspp)
compare1(estim=gammas.estim,true=gammas.true)
m.gammas.estim=mod1$m.gamma[ngibbs,]
compare1(estim=m.gammas.estim,true=m.gamma.true)
tau2.gammas.estim=mod1$tau2.gamma[ngibbs,]
compare1(estim=tau2.gammas.estim,true=tau2.gamma.true)
